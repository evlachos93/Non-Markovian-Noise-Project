
'''---------------------------------------Ramsey Parameter Sweep for Random Telegraph Noise-------------------------------------------'''

'''DESCRIPTION:
    1. Generate ~200 instances of telegraph noise for all parameter points and store them in separate folders
    2. Repeat ramsey measurement with different noise realizations
    3. Every 10 instances, do ramsey without RTN to get statistics for the bare T2*
    4. Repeat for every parameter point
'''
try:
    directory = 'E:\\generalized-markovian-noise\\%s\\sweep_data\\ramsey\\' %(meas_device)
    latest_sweep = max(glob.glob(os.path.join(directory, '*')), key=os.path.getmtime)
    sweep_count = int(latest_sweep[-3:].lstrip('0')) + 1
except:
    sweep_count = 1


numRealizations = 128
b_measurements = 32
numIterations = numRealizations + b_measurements
interval = int(numRealizations/b_measurements) # how often to take background data without generalized markovian noise
B0 = np.linspace(0.0005,0.05,11) #the relationship between B0 and frequency of oscillations is Omega_R = 25 MHz * A_q
# B0 = [0.0005,0.015]
# B0 = [0.05]
# nu = np.linspace(0.05,10,5)
# nu = [0.01,10]
nu = [0]
tau = np.concatenate((np.linspace(0.1,2,7),np.linspace(3,20,4)))
# tau = [0.1,1,2,3,10,10000]
# tau = [0.1,1000]
# tau = [10]

# initialize arrays for data
stepSize_background = 40e-9
Tmax_background = 8e-6
stepSize = 40e-9
Tmax = 15.5e-6
nPoints, nStepsBackground, pulse_length_increment, pulse_length_start = expf.calc_nSteps(sequence='ramsey',fsAWG=1.2e9,stepSize=stepSize_background,Tmax=Tmax_background)
nPoints,nSteps, pulse_length_increment, pulse_length_start = expf.calc_nSteps(sequence='ramsey',fsAWG=1.2e9,stepSize=stepSize,Tmax=Tmax)
bData_I, bData_Q, data_I, data_Q = expf.init_arrays(numRealizations=numRealizations,interval=interval,nPointsBackground=nStepsBackground,nPoints=nSteps)

# make appropriate directories
sweep_name = 'sweep_%03d'%(sweep_count)
parent_dir = 'E:\\generalized-markovian-noise\\%s\\sweep_data\\ramsey\\'%(meas_device)
main_path = os.path.join(parent_dir,sweep_name)
data_path = os.path.join(main_path,'data')
plot_path = os.path.join(main_path,'plot_images')
os.mkdir(main_path)
os.mkdir(data_path)
os.mkdir(plot_path)

# generate noise instances
str_gen_noise = time.time()
expf.gen_noise_realizations(par1_arr=tau,par2_arr=nu,numRealizations=numRealizations,nPoints=nPoints,T_max=Tmax,sweep_count=sweep_count,meas_device=meas_device)
end_gen_noise = time.time()
print('Generating noise realizations took: %.1f s' %(end_gen_noise-str_gen_noise))

plt.close('all')

# sweep ramsey
optionsRamsey_par_sweep = {
    'sampling_rate':    1.2e9,
    'active_reset':     True,
    'threshold':        options_ramsey['threshold'],
    'prePulseLength':   options_ramsey['prePulseLength'],
    'postPulseLength':  options_ramsey['postPulseLength'],
    'nAverages':        256,
    'Tmax':             3e-6,
    'stepSize':         100e-9,
    'pi2Width':         1/2*pi_pulse*1e-9,
    'amplitude_hd':     A_d,
    'sequence':         'ramsey',
    'cav_resp_time': options_ramsey['cav_resp_time'],
    'sweep':            1,
    'measPeriod':       400e-6,
    'qubitDriveFreq':   3.3313e9,
    'AC_pars':          [0.315,0.015],
    'RT_pars':          [0,0,0],
    'AC_freq':          acStarkLO.getFrequency()
    }

par_sweep_time = expf.calc_sweep_time(par1=B0, par2=tau,measTimeBackground=5,measTime=5,nMeasBackground=b_measurements,nMeas=numRealizations)
print('Estimated Sweep Time: %.1f hours = %.1f days'%(par_sweep_time/3600,par_sweep_time/(3600*24)))
start_sweep = time.time()
# generate data
iteration_rabi = 1
for i in range(len(B0)):
    # optionsRamsey_par_sweep['RT_pars'][0] = B0[i]
    for j in range(len(tau)):
        # load noise instances
        noise_realizations = expf.pull_wfm(sweep_name=sweep_name, RT_pars=[B0[i],tau[j],nu[0]])
        start_point_t = time.time()
        filename = 'B0_%d_uV_nu_%d_kHz_tau_%d_ns' %(round(B0[i]*1e6),round(nu[0]*1e3),round(tau[j]*1e3))
        # optionsRamsey_par_sweep['RT_pars'][1] = tau[j]
        a = 0 # keeps track of background measurements
        b = 0 # keeps track of noisy measurements
        k = 0
        #calibrate pi_pulse
        t,I,Q,nPoints = expf.pulse(daq,awg,setup=[0,0,0],**options_rabi)
        fitted_pars,error = pf.fit_data(x_vector=t,y_vector=I,dt=t[-1]/nPoints,**options_rabi)
        optionsRamsey_par_sweep['pi2Width'] = np.round(1/4*fitted_pars[1])*1e-9
        optionsRamsey_par_sweep['threshold'] = round(np.mean([max(I),min(I)])*2**12)
        # fig = pf.plot_data(awg,x_vector=t,y_vector=I,fitted_pars=fitted_pars,**options_rabi,iteration=iteration_rabi)
        # plt.savefig(os.path.join(plot_path,filename+'rabi_fig_%03d.png' %(iteration_rabi)) , bbox_inches='tight')
        # plt.close(fig)
        iteration_rabi += 1
        # print('Next parameter point: B_0 = %.5f V and tau = %.3f microseconds' %(B0[i],tau[j]))
        while k < numIterations:
            if k % (interval + 1) == 0 and a != b_measurements:
                # get background T2* every 10 or so measurements
                optionsRamsey_par_sweep['nAverages'] = 256
                optionsRamsey_par_sweep['RT_pars'] = [0,0,0]
                optionsRamsey_par_sweep['Tmax'] = Tmax_background
                optionsRamsey_par_sweep['stepSize'] = stepSize_background
                print('----------------------------------\nExecuting background Ramsey measurement')
                t2,I,Q,nPoints = expf.pulse(daq,awg,setup=[0,1,0],sweep_name=sweep_name,**optionsRamsey_par_sweep)
                bData_I[a,:] = I
                bData_Q[a,:] = Q
                # fitted_pars,error = pf.fit_data(x_vector=t2,y_vector=I,dt=t2[-1]/nPoints,**optionsRamsey_par_sweep)
                # fig = pf.plot_data(awg,x_vector=t2,y_vector=I,fitted_pars=fitted_pars,dt=t2[-1]/nPoints,**optionsRamsey_par_sweep,iteration=a)
                # save and then clear plot
                # plt.savefig(os.path.join(plot_path,filename+'background_meas_fig_%03d.png'%(a+1)),bbox_inches='tight')
                # plt.close(fig)
                a += 1
                print('End measurement\n----------------------------------' )
            else:
                if k % (interval + 1) == 1:
                    setup = [0,1,0]
                else:
                    setup = [2,1,1]
                optionsRamsey_par_sweep['RT_pars'] = [B0[i],tau[j],nu[0]]
                # optionsRamsey_par_sweep['RT_pars'] = [B0,tau[j],nu[i]]
                optionsRamsey_par_sweep['Tmax'] = Tmax
                optionsRamsey_par_sweep['nAverages'] = 256
                optionsRamsey_par_sweep['stepSize'] = stepSize
                print('----------------------------------\nStart %s measurement' %("ramsey"))
                print('Implementing noise realization %d' %(b+1))
                noise_instance = noise_realizations[b,:]
                t1,I,Q,nPoints = expf.pulse(daq,awg,setup=setup,sweep_name=sweep_name,noise_instance=noise_instance,**optionsRamsey_par_sweep)
                data_I[b,0:nPoints] = I
                data_Q[b,0:nPoints] = Q
                # fitted_pars,error = pf.fit_data(x_vector=t1,y_vector=I,dt=t1[-1]/nPoints,**optionsRamsey_par_sweep)
                # fig = pf.plot_data(awg,x_vector=t1,y_vector=I,fitted_pars=fitted_pars,dt=t1[-1]/nPoints,**optionsRamsey_par_sweep,iteration=b)
                # save and then clear plot
                # plt.savefig(os.path.join(plot_path,filename+'_fig_%03d.png'%(b+1)),bbox_inches='tight')
                # plt.close(fig)
                b += 1
                print('End measurement\n----------------------------------' )
            k += 1


        # save data after each parameter sweep point
        with open("E:\\generalized-markovian-noise\\%s\\sweep_data\\ramsey\\%s\\data\\data_%s.csv"%(meas_device,sweep_name,filename),"w",newline="") as datafile:
            writer = csv.writer(datafile)
            writer.writerow(optionsRamsey_par_sweep.keys())
            writer.writerow(optionsRamsey_par_sweep.values())
            writer.writerow(['Background Time Data'])
            writer.writerow(t2)
            writer.writerow(['Time Data'])
            writer.writerow(t1)
            writer.writerow(['Background Data: Channel 1'])
            writer.writerows(bData_I)
            writer.writerow(['Background Data: Channel 2'])
            writer.writerows(bData_Q)
            writer.writerow(['Data: Channel 1'])
            writer.writerows(data_I)
            writer.writerow(['Data: Channel 2'])
            writer.writerows(data_Q)

        end_point_t = time.time()
        print('Parameter point took %s'%(end_point_t-start_point_t))
        plt.close('all')

end_sweep = time.time()
print('Total Sweep Duration: %.1f s = %.1f hours = %.1f days' %(end_sweep-start_sweep,(end_sweep-start_sweep)/3600,(end_sweep-start_sweep)/(3600*24)))
sweep_count += 1


# average data
T2_avg = np.mean(T2_arr,2)
freq_avg = np.mean(ram_freq_arr,2)
Tb_avg = np.mean(T_b,2)

pf.sweep_plot(tau,1e3*B0,T2_avg)

# plot data
fig, (ax1,ax2) = plt.subplots(2,sharex=True)
ax1.plot(rep,detun_arr, '-o', markersize = 3, c='C0')
ax1.set_ylabel('$\Delta$ (MHz)')
fig.suptitle('Ramsey AC stark sweep %03d'%(iteration_ramsey_statistics))
ax2.plot(rep,T_2_arr, '-o', markersize = 3, c='C0')
ax2.set_xlabel('iteration')
ax2.set_ylabel('$T_{\phi} (\mu s)$')


# save data
exp_pars_ramsey_sweep = [options_ramsey['amplitude_hd'],options_ramsey['qubitDriveFreq'],options_ramsey['AC_pars']]

file = h5py.File("E:\generalized-markovian-noise\%s_data_%03d.h5", 'w')
pars = file.create_group("Experimental Parameters")
data = file.create_group("data")

pars.create_dataset("Experimental Parameters",data=optionsRamsey_par_sweep)
sweep_pars.create_dataset("Tau",data=tau)
sweep_pars.create_dataset("Tau",data=B0)
data.create_dataset("Background Data",data=b_data1)
data.create_dataset("Data",data=data1)
file.close()


'''---------------------------------------Echo Parameter Sweep for Random Telegraph Noise-------------------------------------------'''

'''DESCRIPTION:
    1. Generate instances of telegraph noise for all parameter points and store them in separate folders
    2. Repeat echo measurement with different noise realizations
    3. Every 10 or so instances, do echo without RTN to get statistics for the bare T2
    4. Repeat for every parameter point
'''

sweep_count = 30
numRealizations = 100
b_measurements = 4
numIterations = numRealizations + b_measurements
interval = int(numRealizations/b_measurements) # how often to take background data without generalized markovian noise
B0 = np.linspace(0.01,0.2,10) #the relationship between B0 and frequency of oscillations is Omega_R = 25 MHz * A_q
# tau = np.concatenate((np.linspace(0.01,2,8),np.linspace(3,100,2)))
tau = np.linspace(0.01,0.1,3)
# tau = [0.1,0.7,3]
# B0 = [0.07,0.2]

T2_b = np.zeros((len(B0),len(tau),int(numRealizations/interval)),dtype=float)
b_data1 = np.zeros((len(B0),len(tau),int(numRealizations/interval),112),dtype=float)
b_data2  = np.zeros((len(B0),len(tau),int(numRealizations/interval),112),dtype=float)
error_b = np.zeros((len(B0),len(tau),int(numRealizations/interval)),dtype=float)

T2_arr = np.zeros((len(B0),len(tau),numRealizations),dtype=float)
data1 = np.zeros((len(B0),len(tau),numRealizations,148),dtype=float)
data2 = np.zeros((len(B0),len(tau),numRealizations,148),dtype=float)
error_arr = np.zeros((len(B0),len(tau),numRealizations),dtype=float)
# generate noise instances
Tmax = 4e-6
nPoints = expf.roundToBase(2.4e9*Tmax,16)
str_gen_noise = time.time()
expf.gen_noise_realizations(noiseType='RTN',par1_arr=tau,par2_arr=[0],numRealizations=numRealizations,nPoints=nPoints,T_max=Tmax,sweep_count=sweep_count)
end_gen_noise = time.time()
print('Generating noise realizations took: %.1f s' %(end_gen_noise-str_gen_noise))
sweep_name = 'sweep_%03d'%(sweep_count)
parent_dir = 'E:\\generalized-markovian-noise\\sweep_data\\'
path = os.path.join(parent_dir,sweep_name)
os.mkdir(path)
plt.close('all')

# sweep echo
optionsEcho_par_sweep = {
    'sampling_rate':    2.4e9,
    'nAverages':        512,
    'Tmax':             4e-6,
    'stepSize':         30e-9,
    'integration_length': 2.0e-6,
    'cav_resp_time':    0.5e-6,
    'amplitude_hd':     A_d,
    'sequence':         'echo',
    # 'nSteps':           57,
    'measPeriod':       200e-6,
    'qubitDriveFreq':   options_rabi['qubitDriveFreq']+detun,
    'sweep':            1,
    'pi2Width':         options_echo['pi2Width'],
    'piWidth_Y':       options_echo['piWidth_Y'],
    'pipulse_position': options_echo['pipulse_position'],
    'AC_pars':          options_echo['AC_pars'],
    'RT_pars':          [0,0],
    }

plot = 0
header = ['Amplitude (V)','Drive Freq (Hz)','AC Stark Amplitude (V)','AC stark Noise Amplitude (V)','Pi2 Pulse Width (ns)','Y Pi Pulse Width (ns)','Pi Pulse Position (ns)']
exp_pars = [optionsEcho_par_sweep['amplitude_hd'],optionsEcho_par_sweep['qubitDriveFreq'],optionsEcho_par_sweep['AC_pars'][0],optionsEcho_par_sweep['AC_pars'][1],optionsEcho_par_sweep['pi2Width'],optionsEcho_par_sweep['piWidth_Y'],optionsEcho_par_sweep['pipulse_position']]
start_sweep = time.time()
# B0 = [0.179]
# generate data
for i in range(len(B0)):
    optionsEcho_par_sweep['RT_pars'][0] = B0[i]
    for j in range(len(tau)):
        optionsEcho_par_sweep['RT_pars'][1] = tau[j]
        a = 0 # keeps track of background measurements
        b = 0 # keeps track of noisy measurements
        k = 0
        print('Next parameter point: B_0 = %.2f V and tau = %.2f microseconds' %(B0[i],tau[j]))
        while k < numIterations:
            if k % (interval + 1) == 0 and a != b_measurements:
                # get background T2* every 10 or so measurements
                optionsEcho_par_sweep['RT_pars'] = [0,0]
                optionsEcho_par_sweep['nAverages'] = 1024
                optionsEcho_par_sweep['Tmax'] = 3e-6
                optionsEcho_par_sweep['stepSize'] = 30e-9
                # optionsEcho_par_sweep['nAverages'] = 1 #pars used for testing
                # optionsEcho_par_sweep['Tmax'] = 3e-6
                # optionsEcho_par_sweep['stepSize'] = 1000e-9
                print('----------------------------------\nExecuting background Echo measurement')
                t2,I,Q,nPoints = expf.pulse(daq,awg,qubitLO,setup=[0,1,0],sweep_name=sweep_name,**optionsEcho_par_sweep)
                b_data1[i,j,a,:] = I
                b_data2[i,j,a,:] = Q
                T2_b[i,j,a],error = pf.pulse_plot1d(sequence='echo',x_vector=t2, y_vector=I,plot=plot,dt=optionsEcho_par_sweep['Tmax']*1e6/nPoints,qubitDriveFreq=optionsEcho_par_sweep['qubitDriveFreq'],amplitude_hd=optionsEcho_par_sweep['amplitude_hd'],fitting=1,AC_pars=optionsEcho_par_sweep['AC_pars'],RT_pars=optionsEcho_par_sweep['RT_pars'],pi2Width=optionsEcho_par_sweep['pi2Width'])
                error_b[i,j,a] = max(error)
                a += 1
                print('End measurement\n----------------------------------' )
            else:
                if k % (interval + 1) == 1:
                    setup = [0,1,0]
                else:
                    setup = [2,1,1]

                # if k % 10 == 0:
                #     plot = 1
                # else:
                #     plot = 0

                optionsEcho_par_sweep['RT_pars'] = [B0[i],tau[j]]
                optionsEcho_par_sweep['Tmax'] = 4e-6
                optionsEcho_par_sweep['nAverages'] = 512
                optionsEcho_par_sweep['stepSize'] = 30e-9
                # optionsEcho_par_sweep['Tmax'] = 4e-6 #pars used for testing
                # optionsEcho_par_sweep['nAverages'] = 1
                # optionsEcho_par_sweep['stepSize'] = 30e-9
                print('----------------------------------\nStart %s measurement' %("Echo"))
                print('Implementing noise realization %d' %(b+1))
                t1,I,Q,nPoints = expf.pulse(daq,awg,qubitLO,setup=setup,sweep_name=sweep_name,instance=b,**optionsEcho_par_sweep)
                data1[i,j,b,0:nPoints] = I
                data2[i,j,b,0:nPoints] = Q
                T2_arr[i,j,b],error = pf.pulse_plot1d(sequence='echo',x_vector=t1, y_vector=I,plot=plot,dt=optionsEcho_par_sweep['Tmax']*1e6/nPoints,qubitDriveFreq=optionsEcho_par_sweep['qubitDriveFreq'],amplitude_hd=optionsEcho_par_sweep['amplitude_hd'],fitting=1,AC_pars=optionsEcho_par_sweep['AC_pars'],RT_pars=optionsEcho_par_sweep['RT_pars'],pi2Width=optionsEcho_par_sweep['pi2Width'])
                error_arr[i,j,b] = max(error)
                b += 1
                print('End measurement\n----------------------------------' )
            k += 1

        # save data after each parameter sweep point
        filename = 'RTN_B0_%d_mV_tau_%d_ns' %(round(B0[i]*1e3),round(tau[j]*1e3))
        with open("E:\generalized-markovian-noise\sweep_data\%s\data_%s.csv"%(sweep_name,filename),"w",newline="") as datafile:
        # with open("E:\\generalized-markovian-noise\\sweep_data\\%s\\redo\\data_%s.csv"%(sweep_name,filename),"w",newline="") as datafile:
            writer = csv.writer(datafile)
            writer.writerow(['Background Time Data'])
            writer.writerow(t2)
            writer.writerow(['Time Data'])
            writer.writerow(t1)
            writer.writerow(['Background Data: Channel 1'])
            writer.writerows(b_data1[i,j,:,:])
            writer.writerow(['Background Data: Channel 2'])
            writer.writerows(b_data2[i,j,:,:])
            writer.writerow(['Data: Channel 1'])
            writer.writerows(data1[i,j,:,:])
            writer.writerow(['Data: Channel 2'])
            writer.writerows(data2[i,j,:,:])

end_sweep = time.time()
print('Total Sweep Duration: %.1f s or %.1f hours, or %.1f days' %(end_sweep-start_sweep,(end_sweep-start_sweep)/3600,(end_sweep-start_sweep)/(3600*24)))
sweep_count += 1